export interface TokenBudgetControlOptions {
    id: string;
    name: string;
    label: string;
    description: string;
    helper: string;
    value?: number | null;
    defaultValue?: number | null;
    min?: number | null;
    max?: number | null;
    step?: number | null;
    units?: string;
    allowBlank?: boolean;
    sliderEnabled?: boolean;
    disabled?: boolean;
    emptyLabel?: string;
    defaultLabel?: string;
    specialLabels?: Record<string, string>;
    accent?: "reasoning" | "output";
    manualPlaceholder?: string;
}
export declare function renderTokenBudgetControl(options: TokenBudgetControlOptions): string;
export declare const TOKEN_BUDGET_STYLES = "\n  .token-budget {\n    border-radius: 20px;\n    border: 1px solid var(--border);\n    padding: 18px;\n    background: var(--surface-muted, rgba(255, 255, 255, 0.85));\n    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);\n    display: grid;\n    gap: 16px;\n    position: relative;\n  }\n  .token-budget--reasoning {\n    border-color: rgba(99, 102, 241, 0.32);\n    background: linear-gradient(180deg, rgba(238, 242, 255, 0.7) 0%, rgba(224, 231, 255, 0.45) 100%);\n  }\n  .token-budget--output {\n    border-color: rgba(14, 165, 233, 0.28);\n    background: linear-gradient(180deg, rgba(219, 234, 254, 0.65) 0%, rgba(191, 219, 254, 0.38) 100%);\n  }\n  .token-budget__header {\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    gap: 16px;\n  }\n  .token-budget__label {\n    font-weight: 600;\n    font-size: 0.95rem;\n    color: var(--text);\n    display: block;\n    margin: 0 0 6px;\n  }\n  .token-budget__description {\n    margin: 0;\n    color: var(--muted);\n    font-size: 0.88rem;\n    max-width: 46ch;\n  }\n  .token-budget__badge {\n    background: rgba(30, 64, 175, 0.1);\n    color: rgba(30, 64, 175, 0.8);\n    padding: 6px 12px;\n    border-radius: 999px;\n    font-size: 0.75rem;\n    font-weight: 600;\n    letter-spacing: 0.02em;\n    white-space: nowrap;\n  }\n  .token-budget__slider {\n    display: grid;\n    gap: 8px;\n  }\n  .token-budget__range {\n    width: 100%;\n    accent-color: var(--accent);\n  }\n  .token-budget__scale {\n    display: flex;\n    justify-content: space-between;\n    font-size: 0.75rem;\n    color: var(--subtle);\n  }\n  .token-budget__manual {\n    display: grid;\n    gap: 10px;\n  }\n  .token-budget__manual-label {\n    font-size: 0.82rem;\n    font-weight: 500;\n    color: var(--muted);\n  }\n  .token-budget__manual-row {\n    display: grid;\n    grid-template-columns: minmax(0, 1fr) auto auto;\n    gap: 10px;\n    align-items: center;\n  }\n  .token-budget__manual-input {\n    border-radius: 12px;\n    border: 1px solid var(--border);\n    padding: 10px 12px;\n    font: inherit;\n    background: var(--surface, #fff);\n  }\n  .token-budget__manual-input:focus-visible {\n    outline: 3px solid var(--accent-ring, rgba(59, 130, 246, 0.25));\n    outline-offset: 1px;\n  }\n  .token-budget__unit {\n    font-size: 0.8rem;\n    color: var(--subtle);\n    font-weight: 500;\n  }\n  .token-budget__reset {\n    border: 1px solid transparent;\n    border-radius: 12px;\n    background: rgba(59, 130, 246, 0.12);\n    color: var(--accent, #1d4ed8);\n    font-size: 0.78rem;\n    font-weight: 600;\n    padding: 8px 12px;\n    cursor: pointer;\n  }\n  .token-budget__reset:hover {\n    background: rgba(59, 130, 246, 0.18);\n  }\n  .token-budget__helper {\n    margin: 0;\n    color: var(--subtle);\n    font-size: 0.82rem;\n  }\n  .token-budget__status {\n    margin: 0;\n    font-size: 0.78rem;\n    color: var(--accent);\n  }\n  .token-budget[data-slider-disabled=\"true\"] .token-budget__slider {\n    opacity: 0.45;\n    pointer-events: none;\n  }\n  .token-budget[data-disabled=\"true\"] {\n    opacity: 0.65;\n  }\n  .token-budget[data-slider-outside=\"true\"] .token-budget__badge {\n    background: rgba(185, 28, 28, 0.14);\n    color: rgba(153, 27, 27, 0.85);\n  }\n";
export declare const TOKEN_BUDGET_RUNTIME = "(() => {\n  const controllers = new WeakMap();\n\n  const formatTokenDisplay = (value, units, specialLabels, defaultLabel, emptyLabel, hasValue) => {\n    if (typeof value === \"string\" && value.trim() === \"\") {\n      return emptyLabel;\n    }\n    const numeric = Number(value);\n    if (!Number.isFinite(numeric)) {\n      if (typeof value === \"string\" && value.trim()) {\n        const key = value.trim();\n        if (Object.prototype.hasOwnProperty.call(specialLabels, key)) {\n          return specialLabels[key];\n        }\n        return value.trim();\n      }\n      return emptyLabel;\n    }\n    const key = String(Math.floor(numeric));\n    if (Object.prototype.hasOwnProperty.call(specialLabels, key)) {\n      return specialLabels[key];\n    }\n    const abs = Math.abs(numeric);\n    const sign = numeric < 0 ? \"-\" : \"\";\n    if (abs >= 1_000_000) {\n      return sign + (abs / 1_000_000).toFixed(abs >= 10_000_000 ? 0 : 1) + \"M \" + units;\n    }\n    if (abs >= 1000) {\n      return sign + (abs / 1000).toFixed(abs >= 10_000 ? 0 : 1) + \"K \" + units;\n    }\n    if (!hasValue) {\n      return emptyLabel;\n    }\n    return sign + Math.floor(abs) + \" \" + units;\n  };\n\n  const clamp = (value, min, max) => {\n    if (typeof value !== \"number\" || Number.isNaN(value)) {\n      return value;\n    }\n    if (typeof min === \"number\" && value < min) {\n      return min;\n    }\n    if (typeof max === \"number\" && value > max) {\n      return max;\n    }\n    return value;\n  };\n\n  const computeStep = (min, max, fallback) => {\n    if (typeof min !== \"number\" || Number.isNaN(min) || typeof max !== \"number\" || Number.isNaN(max)) {\n      return fallback;\n    }\n    const span = Math.max(max - min, 1);\n    const rough = span / 200;\n    if (rough <= 1) {\n      return 1;\n    }\n    const pow = Math.pow(10, Math.floor(Math.log10(rough)));\n    let step = pow;\n    for (const base of [1, 2, 5]) {\n      const candidate = base * pow;\n      if (candidate >= rough) {\n        step = candidate;\n        break;\n      }\n    }\n    if (step < rough) {\n      step = 10 * pow;\n    }\n    return Math.max(1, Math.round(step));\n  };\n\n  const parseSpecialLabels = (root) => {\n    const raw = root.getAttribute(\"data-token-special-labels\");\n    if (!raw) {\n      return {};\n    }\n    try {\n      return JSON.parse(raw);\n    } catch (error) {\n      console.warn(\"Failed to parse special labels\", error);\n      return {};\n    }\n  };\n\n  const init = (root, config = {}) => {\n    if (!(root instanceof HTMLElement)) {\n      return null;\n    }\n    if (controllers.has(root)) {\n      const existing = controllers.get(root);\n      if (config && typeof config === \"object\") {\n        existing.configure(config);\n      }\n      return existing;\n    }\n\n    const hiddenInput = root.querySelector(\"[data-token-hidden]\");\n    const slider = root.querySelector(\"[data-token-slider]\");\n    const manualInput = root.querySelector(\"[data-token-manual]\");\n    const badge = root.querySelector(\"[data-token-badge]\");\n    const helper = root.querySelector(\"[data-token-helper]\");\n    const description = root.querySelector(\"[data-token-description]\");\n    const status = root.querySelector(\"[data-token-status]\");\n    const minLabel = root.querySelector(\"[data-token-min-label]\");\n    const maxLabel = root.querySelector(\"[data-token-max-label]\");\n\n    const state = {\n      allowBlank: root.getAttribute(\"data-token-allow-blank\") === \"true\",\n      sliderEnabled: root.getAttribute(\"data-token-slider-enabled\") !== \"false\",\n      disabled: root.getAttribute(\"data-token-disabled\") === \"true\",\n      units: root.getAttribute(\"data-token-units\") || \"tokens\",\n      emptyLabel: root.getAttribute(\"data-token-empty-label\") || \"Provider default\",\n      defaultLabel: root.getAttribute(\"data-token-default-label\") || \"Provider default\",\n      defaultValue: root.getAttribute(\"data-token-default\") || \"\",\n      min: Number(root.getAttribute(\"data-token-min\") || \"0\"),\n      max: Number(root.getAttribute(\"data-token-max\") || \"0\"),\n      step: Number(root.getAttribute(\"data-token-step\") || \"1\"),\n      specialLabels: parseSpecialLabels(root),\n      value: hiddenInput instanceof HTMLInputElement ? hiddenInput.value : \"\",\n      manualPlaceholder: manualInput instanceof HTMLInputElement ? manualInput.placeholder : \"\",\n    };\n\n    const listeners = new Set();\n\n    const emit = (detail) => {\n      listeners.forEach((listener) => {\n        try {\n          listener(detail);\n        } catch (error) {\n          console.error(error);\n        }\n      });\n      root.dispatchEvent(\n        new CustomEvent(\"token-control:change\", {\n          detail,\n        }),\n      );\n    };\n\n    const formatBadge = (rawValue) => {\n      const trimmed = typeof rawValue === \"string\" ? rawValue.trim() : \"\";\n      const hasValue = trimmed.length > 0;\n      if (!hasValue) {\n        const defaultValue = state.defaultValue;\n        if (defaultValue) {\n          const formattedDefault = formatTokenDisplay(defaultValue, state.units, state.specialLabels, state.defaultLabel, state.emptyLabel, true);\n          return formattedDefault + \" \u00B7 \" + state.defaultLabel;\n        }\n        return state.emptyLabel;\n      }\n      return formatTokenDisplay(trimmed, state.units, state.specialLabels, state.defaultLabel, state.emptyLabel, true);\n    };\n\n    const updateSliderRange = () => {\n      if (!(slider instanceof HTMLInputElement)) {\n        return;\n      }\n      const step = state.step || 1;\n      slider.min = String(state.min);\n      slider.max = String(state.max);\n      slider.step = String(step);\n      const currentNumeric = Number(slider.value);\n      if (!Number.isFinite(currentNumeric)) {\n        const candidate = Number(state.defaultValue || state.min || 0);\n        slider.value = String(candidate);\n      } else {\n        const next = clamp(currentNumeric, state.min, state.max);\n        slider.value = String(next);\n      }\n      if (minLabel instanceof HTMLElement) {\n        minLabel.textContent =\n          \"Min \u00B7 \" +\n          formatTokenDisplay(\n            state.min,\n            state.units,\n            {},\n            state.defaultLabel,\n            state.emptyLabel,\n            true,\n          );\n      }\n      if (maxLabel instanceof HTMLElement) {\n        maxLabel.textContent =\n          \"Max \u00B7 \" +\n          formatTokenDisplay(\n            state.max,\n            state.units,\n            {},\n            state.defaultLabel,\n            state.emptyLabel,\n            true,\n          );\n      }\n    };\n\n    const applyValue = (rawValue, source) => {\n      let normalized = typeof rawValue === \"string\" ? rawValue.trim() : \"\";\n      if (!state.allowBlank && !normalized) {\n        normalized = state.defaultValue || String(state.min);\n      }\n      const treatAsBlank = normalized === \"\" && state.allowBlank;\n      const numeric = normalized === \"\" ? Number.NaN : Number(normalized);\n      let sliderInRange = true;\n      let sliderNumeric = Number.NaN;\n      if (slider instanceof HTMLInputElement) {\n        if (Number.isFinite(numeric)) {\n          sliderNumeric = clamp(numeric, state.min, state.max);\n          slider.value = String(sliderNumeric);\n          sliderInRange = sliderNumeric === numeric;\n        } else {\n          const fallback = Number(state.defaultValue || state.min || 0);\n          sliderNumeric = clamp(fallback, state.min, state.max);\n          slider.value = String(sliderNumeric);\n          sliderInRange = treatAsBlank;\n        }\n      }\n      let finalValue = normalized;\n      if (!treatAsBlank && Number.isFinite(sliderNumeric) && !sliderInRange) {\n        finalValue = String(Math.floor(sliderNumeric));\n      }\n      if (hiddenInput instanceof HTMLInputElement) {\n        hiddenInput.value = finalValue;\n      }\n      if (manualInput instanceof HTMLInputElement) {\n        manualInput.value = finalValue;\n      }\n      if (badge instanceof HTMLElement) {\n        badge.textContent = formatBadge(finalValue);\n      }\n      const sliderOutside = !sliderInRange && !treatAsBlank;\n      root.dataset.sliderOutside = sliderOutside ? \"true\" : \"false\";\n      state.value = finalValue;\n      const emittedNumeric = Number(finalValue);\n      emit({\n        raw: finalValue,\n        numeric: Number.isFinite(emittedNumeric) ? emittedNumeric : null,\n        isBlank: finalValue === \"\",\n        source: source || \"api\",\n        withinSlider: sliderOutside ? false : true,\n      });\n    };\n\n    const configure = (nextConfig = {}) => {\n      if (typeof nextConfig !== \"object\" || nextConfig === null) {\n        return;\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"allowBlank\")) {\n        state.allowBlank = Boolean(nextConfig.allowBlank);\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"sliderEnabled\")) {\n        state.sliderEnabled = Boolean(nextConfig.sliderEnabled);\n        root.dataset.sliderDisabled = state.sliderEnabled ? \"false\" : \"true\";\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"disabled\")) {\n        state.disabled = Boolean(nextConfig.disabled);\n        root.dataset.disabled = state.disabled ? \"true\" : \"false\";\n        if (manualInput instanceof HTMLInputElement) {\n          manualInput.disabled = state.disabled;\n        }\n        if (slider instanceof HTMLInputElement) {\n          slider.disabled = state.disabled || !state.sliderEnabled;\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"units\")) {\n        state.units = String(nextConfig.units);\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"emptyLabel\")) {\n        state.emptyLabel = String(nextConfig.emptyLabel);\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"defaultLabel\")) {\n        state.defaultLabel = String(nextConfig.defaultLabel);\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"defaultValue\")) {\n        state.defaultValue = nextConfig.defaultValue === null ? \"\" : String(nextConfig.defaultValue);\n        root.setAttribute(\"data-token-default\", state.defaultValue);\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"min\")) {\n        const min = Number(nextConfig.min);\n        if (Number.isFinite(min)) {\n          state.min = min;\n          root.setAttribute(\"data-token-min\", String(state.min));\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"max\")) {\n        const max = Number(nextConfig.max);\n        if (Number.isFinite(max)) {\n          state.max = max;\n          root.setAttribute(\"data-token-max\", String(state.max));\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"step\")) {\n        const step = Number(nextConfig.step);\n        if (Number.isFinite(step) && step > 0) {\n          state.step = step;\n          root.setAttribute(\"data-token-step\", String(state.step));\n        }\n      } else if (nextConfig.autoStep) {\n        const computed = computeStep(state.min, state.max, state.step || 1);\n        state.step = computed;\n        root.setAttribute(\"data-token-step\", String(state.step));\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"specialLabels\")) {\n        try {\n          state.specialLabels = { ...state.specialLabels, ...nextConfig.specialLabels };\n        } catch (err) {\n          console.warn(\"Failed updating special labels\", err);\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"helper\")) {\n        if (helper instanceof HTMLElement) {\n          helper.textContent = String(nextConfig.helper || \"\");\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"description\")) {\n        if (description instanceof HTMLElement) {\n          description.textContent = String(nextConfig.description || \"\");\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"status\")) {\n        if (status instanceof HTMLElement) {\n          const message = String(nextConfig.status || \"\").trim();\n          if (message) {\n            status.hidden = false;\n            status.textContent = message;\n          } else {\n            status.hidden = true;\n            status.textContent = \"\";\n          }\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"manualPlaceholder\")) {\n        if (manualInput instanceof HTMLInputElement) {\n          manualInput.placeholder = String(nextConfig.manualPlaceholder);\n        }\n      }\n      updateSliderRange();\n      if (Object.prototype.hasOwnProperty.call(nextConfig, \"value\")) {\n        applyValue(nextConfig.value, \"configure\");\n      } else {\n        applyValue(state.value, \"configure\");\n      }\n    };\n\n    if (slider instanceof HTMLInputElement) {\n      slider.addEventListener(\"input\", () => {\n        if (slider.disabled) {\n          return;\n        }\n        const numeric = Number(slider.value);\n        if (Number.isFinite(numeric)) {\n          applyValue(String(Math.floor(numeric)), \"slider\");\n        }\n      });\n    }\n\n    if (manualInput instanceof HTMLInputElement) {\n      const handleManual = () => {\n        if (manualInput.disabled) {\n          return;\n        }\n        applyValue(manualInput.value, \"manual\");\n      };\n      manualInput.addEventListener(\"input\", handleManual);\n      manualInput.addEventListener(\"change\", handleManual);\n    }\n\n    const resetButton = root.querySelector(\"[data-token-reset]\");\n    if (resetButton instanceof HTMLButtonElement) {\n      resetButton.addEventListener(\"click\", (event) => {\n        event.preventDefault();\n        applyValue(state.defaultValue || \"\", \"reset\");\n      });\n    }\n\n    if (state.disabled) {\n      if (slider instanceof HTMLInputElement) {\n        slider.disabled = true;\n      }\n      if (manualInput instanceof HTMLInputElement) {\n        manualInput.disabled = true;\n      }\n    }\n\n    updateSliderRange();\n    applyValue(state.value, \"init\");\n\n    const controller = {\n      configure,\n      getState() {\n        const numeric = Number(state.value);\n        return {\n          raw: state.value,\n          numeric: Number.isFinite(numeric) ? numeric : null,\n          isBlank: !state.value,\n          withinSlider:\n            slider instanceof HTMLInputElement\n              ? Number(slider.value) === clamp(Number(state.value), state.min, state.max)\n              : true,\n        };\n      },\n      setValue(value) {\n        applyValue(value, \"api\");\n      },\n      onChange(listener) {\n        if (typeof listener === \"function\") {\n          listeners.add(listener);\n          return () => listeners.delete(listener);\n        }\n        return () => undefined;\n      },\n    };\n\n    controllers.set(root, controller);\n    if (config && typeof config === \"object\") {\n      controller.configure(config);\n    }\n    return controller;\n  };\n\n  const autoInit = () => {\n    const nodes = document.querySelectorAll(\"[data-token-control]\");\n    nodes.forEach((node) => {\n      init(node);\n    });\n  };\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", autoInit);\n  } else {\n    autoInit();\n  }\n\n  window.__SERVE_LLM_TOKEN_CONTROL = { init };\n})();";
